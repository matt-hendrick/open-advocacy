# Open Advocacy Implementation Plan - FastAPI Approach

## 1. Project Overview

Open Advocacy is an open-source platform connecting citizens with representatives and tracking advocacy projects. This plan focuses on building a FastAPI backend with a flexible database layer and React Vite TypeScript frontend to quickly validate core functionality.

## 2. MVB Approach (Minimum Viable Build)

- **Validate First**: Build the simplest possible version that demonstrates core functionality
- **Use Dummy Data**: Avoid external dependencies until core concepts are proven
- **Modular Components**: Keep parts independent to enable parallel work and flexible evolution
- **Local Development**: Focus on functionality that works on a developer machine first
- **Iterative Growth**: Add complexity only after basic functionality is validated

## 3. Initial Development Phases

### Phase 1: Core Functionality Prototypes

#### FastAPI Backend Prototype
- Create a FastAPI application with Pydantic models for data validation
- Implement basic CRUD endpoints for projects, groups, and entities
- Use in-memory storage initially with option to easily swap in database
- Setup API documentation with Swagger UI (auto-generated by FastAPI)
- Mock the location-based representative lookups with static data

#### Frontend Prototype
- Develop React app with hardcoded representative and project data
- Build UI components for viewing projects and representatives
- Create simple admin form to add/edit projects
- Implement address input with mock response from a static dataset

#### Integration
- Connect frontend to backend API using Axios or Fetch
- Validate data flow between components
- No persistent storage yet

### Phase 2: Core Feature Enhancement

- Add basic user flow for project viewing and representative lookup
- Implement simple voting mechanism with in-memory counter
- Create JSON file persistence as a temporary solution

### Phase 3: Database Integration

- Design database abstraction layer to support multiple providers
- Implement SQLite adapter for local development
- Create SQLAlchemy models matching validated data structure
- Build dependency injection system for database providers
- Implement data migrations strategy for schema evolution

### Phase 4: Location Module Proof of Concept

- Create a minimal Chicago module that demonstrates the pluggable concept
- Use a small static dataset of Chicago wards and representatives
- Implement the basic interface methods defined in the plan
- Test switching between "default" and "Chicago" modules

## 4. Development Setup

### Backend Structure (FastAPI)

```
backend/
├── app/
│   ├── main.py                # Application entry point
│   ├── api/
│   │   ├── routes/            # API endpoints by resource
│   │   │   ├── projects.py
│   │   │   ├── groups.py
│   │   │   └── entities.py
│   │   └── dependencies.py    # Shared dependencies
│   ├── core/
│   │   ├── config.py          # Application configuration
│   │   └── security.py        # Auth functions (for later)
│   ├── db/
│   │   ├── base.py            # Database interface definition
│   │   ├── in_memory.py       # In-memory implementation
│   │   ├── sqlite.py          # SQLite implementation
│   │   └── session.py         # DB session management
│   ├── models/
│   │   ├── pydantic/          # Pydantic models (API schemas)
│   │   └── orm/               # SQLAlchemy models (when added)
│   ├── services/
│   │   ├── project.py         # Business logic for projects
│   │   └── location/          # Location modules
│   │       ├── base.py        # Location module interface
│   │       ├── default.py     # Generic implementation
│   │       └── chicago.py     # Chicago-specific implementation
│   └── utils/                 # Utility functions
├── data/                      # Static data files
│   ├── dummy_projects.tson
│   ├── dummy_entities.tson
│   └── chicago/
│       ├── wards.tson
│       └── representatives.tson
├── tests/                     # Test directory
│   ├── test_api/              # API tests
│   └── test_services/         # Service tests
├── pyproject.toml             # Project dependencies
└── README.md                  # Setup instructions
```

### Frontend Structure (React - IS ACTUALLY TS not JS)

```
frontend/
├── src/
│   ├── components/            # UI building blocks
│   │   ├── Project/
│   │   ├── Group/
│   │   ├── Entity/
│   │   └── common/
│   ├── pages/                 # Main application views
│   │   ├── Home.tsx
│   │   ├── Projects.tsx
│   │   ├── Representatives.tsx
│   │   └── Admin.tsx
│   ├── services/              # API client functions
│   │   ├── api.ts             # Base API setup
│   │   ├── projects.ts
│   │   └── representatives.ts
│   ├── data/                  # Mock data files
│   │   ├── projects.ts
│   │   └── representatives.ts
│   ├── utils/                 # Utility functions
│   └── App.tsx                # Application root
├── public/                    # Static assets
└── package.tson               # Frontend dependencies
```

## 5. Database Abstraction Strategy

The database layer will be designed to support multiple providers through an abstract interface pattern:

```python
# backend/app/db/base.py
from abc import ABC, abstractmethod
from typing import List, Optional, TypeVar, Generic

T = TypeVar('T')

class DatabaseProvider(ABC, Generic[T]):
    @abstractmethod
    async def get(self, id: str) -> Optional[T]:
        pass
    
    @abstractmethod
    async def list(self, skip: int = 0, limit: int = 100) -> List[T]:
        pass
    
    @abstractmethod
    async def create(self, obj_in: T) -> T:
        pass
    
    @abstractmethod
    async def update(self, id: str, obj_in: T) -> Optional[T]:
        pass
    
    @abstractmethod
    async def delete(self, id: str) -> bool:
        pass

# Implementation example for in-memory storage
class InMemoryProvider(DatabaseProvider[T]):
    def __init__(self):
        self.data = {}
        
    async def get(self, id: str) -> Optional[T]:
        return self.data.get(id)
    
    # ... other method implementations

# Later SQLite implementation
class SQLiteProvider(DatabaseProvider[T]):
    def __init__(self, session_maker, model_class):
        self.session_maker = session_maker
        self.model_class = model_class
        
    async def get(self, id: str) -> Optional[T]:
        async with self.session_maker() as session:
            return await session.get(self.model_class, id)
    
    # ... other method implementations
```

## 6. MVB Implementation Steps

1. **Create FastAPI Backend Skeleton**
   - Set up FastAPI application structure
   - Define Pydantic models for data validation
   - Implement basic CRUD endpoints with in-memory storage
   - Add static data files for testing

2. **Create Frontend Skeleton**
   - Set up React app with routing
   - Create static UI components with hardcoded data
   - Implement basic layout and navigation

3. **Implement Core Features**
   - Project listing and details view
   - Representative lookup with dummy response
   - Basic admin form for project creation

4. **Connect Frontend and Backend**
   - Set up Axios for API calls
   - Handle CORS and basic error scenarios
   - Validate data flow end-to-end

5. **Implement Database Abstraction**
   - Create database provider interface
   - Implement in-memory provider
   - Add SQLite provider with SQLAlchemy
   - Build dependency injection system

6. **Develop Location Module Interface**
   - Define location module interface
   - Implement default module with mock data
   - Create Chicago module as proof-of-concept
   - Test module switching mechanism

7. **Test With Scenarios**
   - Define user stories to validate
   - Test admin and user perspectives
   - Document findings and needed adjustments

## 7. Evaluation Points

After completing the MVB, evaluate:

- Is the data model flexible enough for the use cases?
- Does the UI effectively communicate the project status and relationships?
- Is the address-to-representative flow intuitive?
- Can admins easily manage projects and groups?
- Are there any performance concerns even at this small scale?
- How well does the database abstraction handle different providers?
- Is the location module system extensible as designed?

## 8. Next Steps After Validation

Based on evaluation, prioritize:

1. Authentication and authorization system
2. Additional database providers (PostgreSQL, MySQL)
3. Complete Chicago/Illinois specific location module
4. API client library for third-party integrations
5. Deployment infrastructure
6. Additional UI polish and accessibility improvements

## 9. Development Practices

- Use Git from day one with feature branches
- Document code with docstrings and type hints
- Create OpenAPI documentation for all endpoints
- Track issues and enhancements in GitHub Issues
- Write unit tests for critical components
- Use environment variables for configuration